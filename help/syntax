Syntax overview:

At the interactive prompt, enter an <expression>.

    * <expression> → <app> ( `$` <expression> )?

          The `$` acts as right-associative low-priority application.
          It is part of the syntax, not a builtin operator.

    <app> → <app>? <single>

    <single> → <var>
             | (`λ`|'\') (`!`? <var>)+ `.` <expression>
             | `(` <app> `)`
             | <int> | <bool> | <string> | <prim> | <symbol>

        Prefixing an abstraction with `!` makes the function strict in
        that argument.

    <var> a lexeme matching `[a-z][a-zA-Z0-9_]`, which does not
          identify a builtin <prim>itive.

    <bool> → `True` | `False`

    <int> an integer literal.

    <string> a sequence of characters enclosed in `"`s.  The escape
             sequences `\\`, `\"`, `\n` and `\t` are understood.
             You cannot do much with strings though...
    
    <prim> see help topic on primitives: type `:h primitives`.

    <symbol> a lexeme matching `[A-Z][a-zA-Z0-9_]`, which is not one
             of the <bool>eans.
             Symbol really do nothing right now. There is no pattern
             matching.

You may load predefined definitions from a file conforming
to <deflist> with the `:l` command.

    * <deflist> → ( <def> `;` )*

    <def> → <var> <var>* `=` <expression>
